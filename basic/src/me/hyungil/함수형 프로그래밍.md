## 함수형 프로그래밍
- 자바 언어는 완벽한 객체지향 프로그래밍 언어다.
- 모든 코드는 클래스를 설계하고 메서드를 만들어주고 클래스를 통해 객체를 생성해서 사용해야한다.
- 하지만 kotlin은 함수만 만들어 사용하는 것을 지원한다.
- kotlin은 함수 사용을 보다 편리하게 할 수 있도록 다양한 개념들이 존재한다.

**함수를 간략하게 작성하기**
- 다음과 같이 간단한 함수는 한 줄로 작성할 수 있다.
```kotlin
fun testFun1(a1:Int, a2:Int) : Int{
    return a1 + a2
}

fun testFun2(a1:Int, a2:Int) : Int = a1 + a2

fun testFun3(a1:Int, a2:Int) = a1 + a2
```

**람다식**
- 위에서 살펴본 함수와 같은 형태는 람다라는 것으로 바꿔서 사용할 수 있다.
- 특정 함수 내에서만 사용하는 연산 코드를 사용할 때 사용한다.
```kotlin
val lambad1 = {a1:Int, a2:Int -> a1 + a2}

val lambad2 = {a1:Int , a2:Int -> 
    val r1 = a1 + a2
    val r2 = a1 - a2
    r1 * r2
}
```

**정리**
- 매개 변수로 받은 값을 연산하여 반환하는 함수를 만들 때 한줄로 생략해서 만들 수 있다.
- 만약 수식을 계산하는 함수의 코드를 특정 부분에서만 사용한다면 람다로 만들어 사용할 수 있다.

### 익명 함수
- 함수의 이름이 없는 함수이다.
- 함수를 변수에 담아 관리할 때 사용한다.
- 뒤에서 배울 고차함수와 관련이 깊다.
- 이름이 없는 함수를 익명 함수라고 한다.
```kotlin
val testFun2 = fun() {
    println("testFun2입니다.")
}
```

### 인라인 함수
- kotlin 코드가 java 코드로 변경될 때 함수를 호출하는 코드를 함수내에 구현한 코드로 변경하는 함수이다.
- 함수 호출 방식은 전체 코드양이 줄어들어 메모리를 적게 쓴다는 장점이 있지만 호출 시 코드 흐름이 이동하고 다시 돌아와야 하기 때문에
  작업량이 늘어난다.
- 인라인 함수는 전체 코드양이 늘어 메모리를 더 많이 사용하지만 코드 흐름의 이동 없이 수행되기 떄문에 작업량이 늘어나지 안는다.

**일반 함수**
```kotlin
fun main() {
    testFunc1()
    testFunc2()
}

fun testFunc1() {
    println("----------------------")
    println("testFunc1")
    println("----------------------")
    // 다시 돌아가서 testFunc2() 실행
}
```

**인라인 함수**
```kotlin
fun main() {
    testFunc2()
    testFunc2()
}

inline fun testFunc2() {
    println("----------------------")
    println("testFunc2")
    println("----------------------")
}

->

fun main(){
    println("----------------------")
    println("testFunc2")
    println("----------------------")
    println("----------------------")
    println("testFunc2")
    println("----------------------")
}
```

**정리**
- 함수가 호출되는 것이 아닌 함수의 코드가 복사되어 수행되는 함수를 inline 함수라고 한다.

### 확장 함수
- 기존 클래스에 새로운 함수를 추가하는 개념이다.
- kotlin 코드에서는 기존 클래스에 메서드를 추가해 사용 하는 것 처럼 보이지만 사실 객체의 주소 값을 받은 하무가 만들어지고
  그 함수를 호출하는 방식으로 동작한다.
- 확장 함수는 기존 클래스에 새로운 메서드를 추가하고자 할 때 사용한다.  

