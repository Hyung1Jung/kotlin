## 객체지향 프로그래밍

- 객체 지향 프로그래밍이란 프로그램에서 사용되는 여러 데이터나 기능을 객체로 묶어서 관리하는 프로그래밍 기법이다.
- 객체는 매개체 하나에 대한 정보와 기능을 담고 있는 프로그램 요소이다.

### 객체지향 프로그래밍

**객체의 특징**
- 매개체 하나의 정보를 관리하기 위해서는 객체 하나가 필요하며 관리하고자 하는 매개체의 수 만큼 객체를 생성해야 한다.
- 객체는 독립적으로 관리되며 서로에 대해 관여하지 않는다.

**클래스**
- kotlin애서 객체는 자바와 동일하게 클래스를 설계하고 이를 통해 생성한다.
- 클래스에 정의한 변수와 메서드(함수)의 구조대로 객체가 생성되며 같은 형태의 각체가 필요하다면 같은 클래스로 객체를
  생성하면 된다.
  
```kotlin
class 클래스명 {
}
```  

**정리**
- 매개체 하나의 정보와 기능을 관리하는 것을 객체라고 부르며 객체를 활용하여 프로그래밍 하는 기법을 객체 지향
  프로그래밍이라고 부른다.
- 객체는 클래스를 통해 생성할 수 있으며 같은 형태의 객체가 다 수 필요하다면 같은 클래스로 객체를 무수히
  만들어 사용하면 된다.
  
**생성자**
- 클래스를 통해 객체를 생성할 때 자동으로 수행될 코드를 작성하는 곳이다.
- 메서드와 비슷해보이지만 반환 타입이 없어 메서드라고 부르지 않는다.
- 생성자의 역할은 클래스가 가지고 있는 변수의 값을 초기화 하는데 주로 이동된다.

**init 코드 블럭**
- kotlin은 클래스에 init 코드 블록을 만들어 주면 객체 생성시 자동으로 처리되는 코드를 만들 수 있다.
```kotlin
class TestClass1 {
    init{
        println("객체가 생성되면 자동으로 동작하는 부분입니다.")
    }
}
```

**생성자**
- constructor를 이용하여 생성자를 정의할 수 있다.
- 생성자는 매개변수의 개수나 자료형을 달리하여 여러 개를 만들어 사용할 수 있다.
```kotlin
constructor(){
}
constructor(a1:Int, a2:Int){
}
```

**기본 생성자**
- 클래스를 정의할 때 클래스 이름 우측에 정의하는 생성자
- 기본 생성자의 매개 변수는 멤버 변수로 자동 등록된다.

```kotlin
class TestClass3 constructor(var a1:Int, var a2:Int) {
}
```

**정리**
객체가 생성될 때 자동으로 동작하는 부분을 생성자라고 부른다.

### 상속
- 클래스는 객체를 생성 할 때 사용하는 설계도 역할을 한다.

**상속**
- 클래스를 설계할 때 다른 클래스가 가지고 있는 부분을 물려 받는 것을 의미한다.
- 이를 통해 클래스마다 중복된 부분을 클래스 한 곳에 만들 수 있다.
- 상속을 하는 클래스를 부모 클래스라고 하며 상속을 받는 클래스를 자식 클래스라고 한다.
- 부모 클래스는 open 키워드를 사용해야 한다. open 키워드를 사용하지 않으면 자바 코드로 변경될 때
  final 키워드가 붙는다.
```kotlin
open class Super{
}
class Sub1 : Super1 {
}
```  

**정리**
- 클래스를 설계 할 때 클래스에 정의한 요소를 그대로 물려받는 것을 상속이라고 부른다.
- 부모클래스를 정의할 때는 open 키워드를 사용한다.

### 모듈
- kt 파일들을 모아 관리하는 개념이 패키지라면 모듈을 패캐지를 모아 관리하는 개념이다.
- 패키지가 많아지면 관리하기가 어려워질 수 있는데 이 때 모듈로 묶어서 사용한다.
- 패키지들을 모아 관리하는 개념을 모듈이라고 부른다.

### 접근 제한자
- 객체가 가지고 있는 변수는 연산자를 통해 자유롭게 접근이 가능하다.
- 만약 변수에 담기는 값이 어떠한 조건이 있을 경우 외부에서 자유롭게 접근 할 수 있다면 엉뚱한 값이 저장될 가능성이 있다.
- 이에 변수나 메서드의 접근 권한을 설정할 수 있는 접근 제한자를 제공하고 있으며 클래스를 설계하는 개발자가 각 변수나
  메서드의 접근 권한을 설정해 오동작 하는 것을 사전에 막을 수 있게 한다.

**동작 원리**
- kotlin에서는 클래스의 정의한 모든 변수는 java 코드로 변경될 때 private가 설정된다.
- 접근 제한자 종류에 따라 java 코드로 변경될 때 getter 메서드 추가 여부가 결정된다.

**클래스**
- private : 외부에서 객체를 생성할 수 없다
- public : 외부에서 객체를 생성할 수 있다.(기본)
- protected : 클래스에 지정할 수 없다.
- internal : 모듈이 같은 경우에만 객체를 생성할 수 있다.

**변수, 메서드**
- 변수와 메서드는 동일하게 적용된다.
- private : 외부에서 객체를 생성할 수 없다
- public : 외부에서 접근이 자유롭다.(기본)
- protected : 상속관계일 경우에만 접근이 가능하다.
- internal : 모듈이 같을 경우에만 접근이 가능하다.

### Property
**캡슐화**
- 객체가 가지고 있는 변수는 메서드에 구현한 코드가 정상적으로 동작하기 위한 데이터를 담고 있다.
- 만약 변수에 엉뚱한 데이터가 담긴다면 구현한 코드가 정상적으로 동작한다고 하더라도 정상적인 결과가 나올 수 없게 된다.
- 이에 변수의 직접적인 접근을 차단하여 외부에서 값을 변경하지 못하도록 막는 것을 캡술화라고 한다.

**Property**
- 캡슐화가 적용된 변수는 외부에서의 접근이 차단된다.
- 캡술화가 적용된 변수에 대해 메서드를 통해 값을 설정하거나 가져다 사용할 수 있도록 구성한 것을 Property라고 한다.
- 변수에 값을 넣는 메서드를 setter라고 부른다.
- 변수가 가지고 있는 값을 반환하는 메서드를 getter라고 부른다.

**Property 작성 방법**
- private 키워드를 변수에 설정하여 외부에서 접근하지 못하도록 막는다.
- 변수들 중에 외부에 공개하고자 하는 변수에 대해 setter와 getter를 지정한다.

**주 생성자 사용하기**
- 주 생성자의 매개 변수를 사용할 때, var, val를 지정하면 Property로 작성된다.
- var은 getter, setter 모두 작성된다.
- val은 getter만 작성된다.
- 디컴파일 해서 자바 코드로 확인해보면 var, val의 Property 확인 가능.
- 기본 생성자에 var, val을 선언해주면 자동으로 멤버 변수(a1, a2)가 생성된다.
```kotlin
class Test Class1(var a1:Int, val a2:Int)
```

**클래스의 멤버 변수**
- 클래스의 변수를 선언할 때 var와 val에 따라 Property가 작성된다.
- var은 getter, setter 모두 작성된다.
- val은 getter만 작성된다.
```kotlin
class TestClass2(a1:Int, a2:Int) {
    var v1 :Int = a1;
    val v2: Int = a2; 
}
```

**정리**
- 외부에서 변수에 대해 직접적인 접근을 차단하는 것을 캡슐화라고 부른다.
- 캡슐화를 적용한 변수에 값을 넣거나 가져다 사용할 수 있도록 setter/getter를 설정한 것을 Property라고 부른다.

### 지연 초기화
- kotlin은 변수를 선언할 때 값을 무조건 설정해놔야 하는데 이를 지연시키는 것이 지연 초기화라고 한다.

**lateinit**
- var로 선언된 변수의 초기화를 뒤로 미룰 수 있다.
- 변수의 값을 사용하기 전에 반드시 초기화가 이루어져야 한다.
- val로 선언된 변수는 오류가 발생한다.

```kotlin
lateinit var a3:String
```

**lazy**
- val로 선언된 변수는 lateinit으로 지연 초기화 하는 것이 불가능하다.
- val로 선언된 변수는 laze 코드 블록을 이용하면 되는데 이는 나중에 프로퍼티의 값을 셋팅해준다는 의마가 아닌
  사용할 때 값을 초기화 한다는 의미를 가지고 있다.
  
**정리**
- 프로퍼티의 값을 나중에 셋팅할 때 지연 초기화를 사용한다.
- var 변수는 lateinit를 사용한다.
- val 변수는 lazy 코드 블록을 이용한다.

### Overriding

**부모 클래스 타입의 변수**
- kotlin의 모든 객체는 부모 클래스형 변수에 담을 수 있다.
- 부모 클래스형 참조 변수를 사용하면 부모 클래스에 정의되어 있는 멤버만 사용 가능하다.

**Overriding**
- 부모 클래스가 가지고 있는 메서드를 자식 클래스에서 재정의 하는 것이다.
- 부모가 가지고 있는 메서드의 이름, 매개 변수 형태 모두 동일해야 한다.

**Overriding의 효과**
- 만약 객체가 부모형 참조 변수에 담겨 있다면 부모 영역에 정의한 멤버만 정의할 수 있다.
- 만약 부모의 메서드를 자식에서 Overring을 했다면 부모형 참조 변수를 통해 자식의 메서드를 호출 할 수 있다.
- 이는 이벤트 처리 방식에서 사건이 발생했을 경우 개발자가 만든 메서드를 호출하기 위해 사용하는 매우 중요한 개념이다.

**Super**
- 메서드를 Overriding한 경우 부모의 메서드를 호출하고자 한다면 super을 사용한다.
- super은 상속관계에서 부모를 의미한다.

**정리**
- 부모형 참조변수에 객체의 주소 값을 담으면 부모 클래스 영역에 정의한 멤버 변수에 접근할 수 있다.
- 만약 자식에서 메서드를 Overriding 했다면 부모형 참조 변수에서 자식의 메서드를 호출할 수 있다.

### Any Class
- Kotlin에서 사용하는 모든 클래스의 부모 클래스이다.
- Kotlin은 클래스를 작성할 때 상속받지 않는다면 자동으로 Any 클래스를 상속받는다.
- Any 클래스에는 모든 객체가 가지고 있어야할 메서드가 제공되고 있으며 이 메서드들을 Overridng하여
  각 클래스의 성격에 맞게 재 구현 할 수 있다.
  
### this와 super

**this**
- 객체 자기 자신을 지칭한다.
- 멤버 변수와 메서드 내부의 변수를 구분할 때 사용한다.
- 멤버 메서드와 메서드 내부의 메서드를 구분할 때 사용한다.
- 생성자에서 다른 생성자를 호출할 때 사용한다
  
**super**
- 부모 영역을 지칭한다.
- 멤버 변수와 상속받은 멤버 변수를 구분할 때 사용한다.
- Overriding한 메서드와 부모의 메서드를 구분할 때 사용한다.
- 부모의 생성자를 호출할 때 사용한다.

**정리**
- this : 객체 자기 자신을 지칭한다.
- super : 부모를 지칭한다.

### 추상 클래스

**추상 클래스와 메서드**
- 추상 메서드는 구현되지 않은 메서드를 의미한다.
- 추상 클래스는 추상 메서드를 가지고 있는 클래스를 의미한다.
- 추상 클래스는 구현 되지 않은 추상 메서드를 가지고 있기 때문에 완벽한 설계도라고 할 수 없다.
- 이 때문에 추상클래스를 통해서 객체를 생성할 수 없다.

**추상 클래스의 상속**
- 추상 클래스는 완벽한 클래스가 아니기 때문에 객체를 생성할 수 없다.
- 객체를 생성하려면 추상 클래스를 상속받은 클래스를 만들고 추상 메서드를 구현하여 자식 클래스를 통해 객체를 생성해야 한다.
- 추상 클래스의 목적은 자식 클래스에서 메서드를 Overriding을 하게 하기 위한 강제성을 부여하기 위함이다.

**추상 클래스 사용**
```kotlin
open abstract class Super1 {
    fun method1() {
        println("Super1의 method1입니다.")
    } 
  
    open abstract fun method2()
}
```

**정리**
- 구현되지 않은 메서드를 추상 메서드라고 부르며 추상 메서드를 가지고 있는 클래스를 추상 클래스라고 부른다.
- 추상 클래스는 자식 클래스에서 메서드를 Overriding 하게 하기 위함이다.